#pragma once
#include "ListAbstract.h"
#include "Mem.h"

class List : public AbstractList
{
private:

	// количество элементов в списке
	size_t list_Size;  

	//размер листа в байтах
	size_t mem_Size_List;

public:

	//класс исключения
	//Выбрасывает текст о исключении
	//имеет поле char, а точнее массив char[256]
	class Error 
	{
	public:
		char msg[256]; 
		Error(const char* err_msg)
		{
			strcpy(msg, err_msg);
			cout << msg << endl;  
		}
	};

	//Конструктор List
	//Принимает константую ссылку на объект типа MemoryManager.
	//head указывает на nullptr
	//list_size устанавливается в 0
	List(MemoryManager& mem); 

	//деструктор List
	//Удаляет все элементы в списке, очищает его.
	//использует метод clear()
	~List();

	//Методы из ListAbstract.h

	//добавление элемента в начало списка
	//На вход принимает ссылку на область памяти и размер этой области памяти
	//На выходе выдает 0 в случае успеха, иначе 1
	//Выделяет блок памяти с помощью MemoryManger, переносит побитово в эту область памяти некотурую информацию
	//Создает узел, Node, который сохраняет ссылку на эту область памяти и размер данной памяти
	//новый элемент становиться head, головным элементом списка.
	//Увеличивает счетчик занятой памяти (mem_Size_List) в MemoryManager и инкрементирует счетчик узлов в списке (list_Size)
	int push_front(void* elem, size_t elemSize);						
	
	//удаление элемента из начала списка 
	//Вариант реализации - недействительный: Вызывает исключение, если haed списка есть nullptr
	//Вариант реализации - действительный: При head == nullptr метод завершается без удаления.
	//В противном случае освобождает выделенную память в MemoryManager
	//Умеьшаяются значения mem_Size_List и list_Size.
	//Удаление самого Node из List.
	void pop_front();				

	//возвращает указатель на первый элемент в списке
	//Неявно возвращает размер данных, которые содержит Node-Head
	//Вариант реализации - недействительный: Вызывает исключение, если haed списка есть nullptr
	//Вариант реализации - действительный: При head == nullptr метод выдаст nullptr.
	void* front(size_t& size);									

	//добавление нового элемента на позицию на которую указывает итератор
	//Принимает на вход итератор, указатель на область бамяти, в который содержиться элемент, который будем добавлять, и размер этого элемента в байтах
	//В случае успешного добавления функция возвращает значение 0, в случае неудачи 1
	//Выделяет блок памяти с помощью MemoryManger, переносит побитово в эту область памяти некотурую информацию
	//Создает узел, Node, который сохраняет ссылку на эту область памяти и размер данной памяти
	//С помощью цикла и с помощью проверки указателей на область памяти у iter и у prevNode (для нахождения нужной позиции в списке)
	//находим нужную позицию. Проверкой является сравнение этих указателей итератора и узла.
	//В случае нахождения, на эту позицию ставиться новый узел. Меняем указатели на ближних узлах
	//Увеличивает счетчик занятой памяти (mem_Size_List) в MemoryManager и инкрементирует счетчик узлов в списке (list_Size)
	int insert(Iterator* iter, void* elem, size_t elemSize); 

	//Меотды из Container.h

	//возвращет количество элементов в списке 
	//возвращает поле list_Size
	int size();                

	//Функция возвращает значение, равное максимальной вместимости контейнера в байтах
	//Возвращает значение, которое возвращает метод MemoryManager, а точнее метод _memory.size()
	size_t max_bytes();                                           

	//создание итератора, который указывает на элемент списка, который содержит в себе elem
	// Принимает указатель на область памяти, где храниться элемент, который мы ищем, и его размер в байтах. 
	//Создается итератор, который и будет возвращен
	//В цикле с помощью побитового сравнения двух областей памяти, а точнее elem и Node::elem.
	//Если данный узел не является искомым, проверяется наличие слудеющего элемента. (hasNext())
	//В случае его присутсвия - переходим в него. (goToNext())
	//В противном - возвращаем nullptr
	Iterator* find(void* elem, size_t size);

	// создание итератора, который указывает на первый элемент в списке
	//создается итератор типа List::Iterator
	//В случае, если head == nullptr, возвращает nullptr
	Iterator* newIterator();              

	//Удаление элемента с позиции на который указывает итератор
	//После удаления итератор указывает на следующий за удаленным элемент.
	//Если список пуст, то вызывается исключение. Оно ника
	void remove(Container::Iterator* iter);         //ДОКОКНЧИТЬ ОПИСАНИЕ

	//удаление всех элементов в списке
	//циклично использует pop_front()
	//Заканчивается, как только hasNext() говорит, что нет следующего элемента.
	void clear();												  

	//проверка на наличие элементов в списке
	//Если контейнер пуст возвращает true, иначе false
	bool empty();	

	//class Iterator : public Container::Iterator					  //перенести в private или в protected GroupList. рассмотреть 
	//{
	//public: //в случае переноса всего класса сделать поля public
	//	Node* address;
	//	Node* prev_elem;
	//	Node* headInIter;
	//	//методы тут не нужны. Так как реализация будет восприниматься как реализация из container. так как они похожи. Тогда можно перенести node в protected листа или вообще в groupList

	//	//Конструктор Итератора
	//	//Заполняются поля address, first_elem, last_elem, lst;
	//	Iterator();

	//	//получение ссылки на объект элемента в списике
	//	//Возврашает явно указатель на элемент, на который указывает итератор в данный момент.
	//	//Неявно возвращает размер данных.
	//	//Если итератор показывает за пределы контейнера (например, удален последний элемент), возвращает NULL.
	//	void* getElement(size_t& size);

	//	//проверка на наличие следующего элемента
	//	// Возвращает true, если есть следующий элемент, иначе false.
	//	//Если список пустой, то выдает false
	//	bool hasNext();

	//	//переход к следующему элементу 
	//	//Если дошел до конца, в следующем шаге переходит на head 
	//	void goToNext();

	//	//проверка на совпадение элементов
	//	//Проверка производится при помощи побитового сравнения указателей на область памяти, где хранитятся данные
	//	//Возвращает true если совпадают, иначе false
	//	bool equals(Container::Iterator* right);
	//};
};

