#include<iostream>
#include "TableTest.h"
#include <string.h>
using std::cout;
using std::endl;

#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>

 //   _CRT_SECURE_NO_WARNINGS
//#pragma warning(disable:4996)

int main()
{
    Memory_Manager_Table mem(30);
	Table t(mem);
	TableTest test(&t);
	test.check_insertByKey(5000);
	test.check_findByKey();
	//test.check_find();
	test.check_removeByKey();
	test.check_remove();

	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG);
	_CrtDumpMemoryLeaks();

	return 0;
}












































/*
class List {
	int i_;
public:
	List(int i) :i_(i) {
		cout << "C-tor i = " << i << endl;
	}
	~List() {
		cout << "D-tor i = " << i_ << endl;
	}
};

int main()
{

	List* arr;
	const int n = 10;
	arr = (List*)(malloc(sizeof(List) * n));
	for (int i = 0; i < n; ++i)
		new(&arr[i]) List(i);


	for (int i = 0; i < n; ++i)
		arr[i].~List();
	free(arr);
}
*/


//Название контейнера : Table
//Названия требуемых файлов : Table.h, Table.cpp, GroupContainer.h и Mem.h


//Каждый студент должен реализовать один контейнерный класс, один класс для работы
//с памятью и провести эксперимент с ними с целью оценки эффективности алгоритмов. 
//Работа ведется в группах по 6-7 человек. Внутри одной группы разрешается создавать
//свою иерархию классов: выводить из класса Container подклассы, которые в свою очередь
//будут базовыми классами для конкретных контейнеров. Если несколько студентов используют
//один и тот же промежуточный класс, каждый из них посылает его копию. Класс для работы
//с памятью у каждого свой, он должен быть выведен из класса MemoryManager. 
//Описания классов Container и MemoryManager менять не разрешается - в тестах будут
//использоваться исходные их версии. На данном этапе требуется предварительная
//(неоптимизированная) реализация контейнера (<имя_контейнера>.h и <имя_контейнера>.cpp файлы).
//Все контейнеры могут использовать для выделения памяти под элементы встроенный оператор
//new (класс Mem из Mem.h). Функция main размещается в отдельном файле (можно использовать,
//например, ContainerMain.cpp). В любом случае этот файл на сервер решений не отсылается,
//равно как и остальные файлы проекта (vcproj и прочие)!!! 

//Примечание 1: соблюдайте имена классов и файлов с точностью до больших / маленьких букв!

//Примечание 2 : сложность реализации контейнеров разная : множество, дерево
//и таблица посложнее, остальные попроще.Те, кому достались "простые" контейнеры,
//должны для получения высокой оценки получить серьезные результаты на следующих 
//этапах.Например, если ваш менеджер памяти страничный, оптимизированный вектор
//должен уметь размещаться на нескольких страницах.Про то, как хорошо написать 
//тестовый класс, мы говорили на семинарах(сравнение с правильным, реализованным,
//например, на базе vector).

//Примечание 3 : конструкторы всех классов(контейнеров и Mem) должны иметь в точности
//те же параметры, что и конструкторы базовых классов!