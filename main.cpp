#include<iostream>
#include "Table.h"
#include "Mem.h"
using std::cout;
using std::endl;

int main()
{
	Mem m(5);
	Table t(m);
	return 0;
}












































/*
class List {
	int i_;
public:
	List(int i) :i_(i) {
		cout << "C-tor i = " << i << endl;
	}
	~List() {
		cout << "D-tor i = " << i_ << endl;
	}
};

int main()
{

	List* arr;
	const int n = 10;
	arr = (List*)(malloc(sizeof(List) * n));
	for (int i = 0; i < n; ++i)
		new(&arr[i]) List(i);


	for (int i = 0; i < n; ++i)
		arr[i].~List();
	free(arr);
}
*/


//Название контейнера : Table
//Названия требуемых файлов : Table.h, Table.cpp, GroupContainer.h и Mem.h


//Каждый студент должен реализовать один контейнерный класс, один класс для работы
//с памятью и провести эксперимент с ними с целью оценки эффективности алгоритмов. 
//Работа ведется в группах по 6-7 человек. Внутри одной группы разрешается создавать
//свою иерархию классов: выводить из класса Container подклассы, которые в свою очередь
//будут базовыми классами для конкретных контейнеров. Если несколько студентов используют
//один и тот же промежуточный класс, каждый из них посылает его копию. Класс для работы
//с памятью у каждого свой, он должен быть выведен из класса MemoryManager. 
//Описания классов Container и MemoryManager менять не разрешается - в тестах будут
//использоваться исходные их версии. На данном этапе требуется предварительная
//(неоптимизированная) реализация контейнера (<имя_контейнера>.h и <имя_контейнера>.cpp файлы).
//Все контейнеры могут использовать для выделения памяти под элементы встроенный оператор
//new (класс Mem из Mem.h). Функция main размещается в отдельном файле (можно использовать,
//например, ContainerMain.cpp). В любом случае этот файл на сервер решений не отсылается,
//равно как и остальные файлы проекта (vcproj и прочие)!!! 

//Примечание 1: соблюдайте имена классов и файлов с точностью до больших / маленьких букв!

//Примечание 2 : сложность реализации контейнеров разная : множество, дерево
//и таблица посложнее, остальные попроще.Те, кому достались "простые" контейнеры,
//должны для получения высокой оценки получить серьезные результаты на следующих 
//этапах.Например, если ваш менеджер памяти страничный, оптимизированный вектор
//должен уметь размещаться на нескольких страницах.Про то, как хорошо написать 
//тестовый класс, мы говорили на семинарах(сравнение с правильным, реализованным,
//например, на базе vector).

//Примечание 3 : конструкторы всех классов(контейнеров и Mem) должны иметь в точности
//те же параметры, что и конструкторы базовых классов!